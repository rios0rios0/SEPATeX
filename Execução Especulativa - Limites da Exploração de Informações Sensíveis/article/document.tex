% ------------------------------------------------------------------------
% ------------------------------------------------------------------------
% Modelo de Artigo Acadêmico
% Em conformidade com:
% ABNT NBR 6022:2018: Informação e Documentação - Artigo em Publicação Periódica Científica - Apresentação
%
% Adaptado para:
% SEPA: Seminário Estudantil de Produção Acadêmica da UNIFACS
%
% Baseado na Biblioteca abnTeX2 v1.9.7
% ------------------------------------------------------------------------
% ------------------------------------------------------------------------
\documentclass[
	% Opções da classe memoir
	article,			    % indica que é um artigo acadêmico
	12pt,				    % tamanho da fonte
	oneside,			    % para impressão apenas no recto. Oposto a twoside
	a4paper,			    % tamanho do papel. 
	% Opções da classe abntex2
	chapter=TITLE,		    % títulos de capítulos convertidos em letras maiúsculas
	section=TITLE,		    % títulos de seções convertidos em letras maiúsculas
	subsection=TITLE,	    % títulos de subseções convertidos em letras maiúsculas
	%subsubsection=TITLE    % títulos de subsubseções convertidos em letras maiúsculas
	% Opções do pacote babel
	english,			    % idioma adicional para hifenização
	brazil,				    % o último idioma é o principal do documento
	sumario=tradicional
]{abntex2}
% ------------------------------------------------------------------------
% PACOTES
% ------------------------------------------------------------------------
% Pacotes fundamentais 
\usepackage{times}			    % Usa a fonte Times New Roman
\usepackage[T1]{fontenc}		% Selecao de codigos de fonte.
\usepackage[utf8]{inputenc}		% Codificacao do documento (conversão automática dos acentos)
\usepackage{indentfirst}		% Indenta o primeiro parágrafo de cada seção.
\usepackage{nomencl} 			% Lista de simbolos
\usepackage{color}				% Controle das cores
\usepackage{graphicx}			% Inclusão de gráficos
\usepackage{microtype} 			% Para melhorias de justificação
% Pacotes adicionais, usados apenas no âmbito do Modelo Canônico do abnteX2
\usepackage{lipsum}				% Para geração de dummy text
% Pacotes de citações
\usepackage[brazilian,hyperpageref]{backref}	 % Paginas com as citações na bibliografia
\usepackage[alf,bibjustif,abnt-emphasize=bf,abnt-etal-text=emph]{abntex2cite}  % Citações padrão ABNT, forçar a justificação da bibliografia e enfatizar com negrito
% Pacotes extras 
\usepackage{fancyhdr}           % Personalização do cabeçalho e rodapé
\usepackage{listings}           % Personalização de código
\usepackage{listings/c/style}   % Incluí estilo customizado para linguagem C
% ------------------------------------------------------------------------
% CONFIGURAÇÃO DOS PACOTES
% ------------------------------------------------------------------------
% Configurações do pacote backref
% Usado sem a opção hyperpageref de backref
\renewcommand{\backrefpagesname}{Citado na(s) página(s):~}
% Texto padrão antes do número das páginas
\renewcommand{\backref}{}
% Define os textos da citação
\renewcommand*{\backrefalt}[4]{
	\ifcase #1
		Nenhuma citação no texto.
	\or
		Citado na página #2.
	\else
		Citado #1 vezes nas páginas #2.
	\fi
}
% Configuração dos nomes padrões do babel
%\addto\captionsbrazil{
%    \renewcommand{\bibname}{Referências Bibliográficas}
%}
% Configuração do título das referências (anteriormente modificado)
\renewcommand{\bibsection}{%
    \section*{\bibname}
    \bibmark
    \ifnobibintoc\else
        \phantomsection
    \fi
    \prebibhook
}
% Modificando o tamanho da fonte "large" que é 14.4pt, para 14pt
%\renewcommand{\large}{\fontsize{14}{14}\selectfont}
% Modificando título das listagens de código
\renewcommand{\lstlistingname}{Figura}
% ------------------------------------------------------------------------
% DADOS DO DOCUMENTO
% ------------------------------------------------------------------------
% Informações de dados para capa
\autor{\normalsize{\textbf{Felipe Rios da Silva Cordeiro}}}
\instituicao{
    UNIFACS - UNIVERSIDADE SALVADOR
    ESCOLA DE ARQUITETURA, ENGENHARIA\\ E TECNOLOGIA DA INFORMAÇÃO
    BACHARELADO EM ENGENHARIA DA COMPUTAÇÃO
}
\titulo{\uppercase{\normalsize{\textbf{EXECUÇÃO ESPECULATIVA:\\
LIMITES DA EXPLORAÇÃO DE INFORMAÇÕES SENSÍVEIS}}}}
\local{Salvador}
%\data{2019}
\tipotrabalho{Trabalho de Conclusão de Curso, Graduação}
\preambulo{Trabalho de conclusão de curso apresentado ao curso de graduação em Engenharia da Computação da Universidade Salvador - UNIFACS, como requisito fundamental para obtenção do título de Engenheiro da Computação.}
\orientador[Orientador:]{\normalsize{\textbf{Éldman de Oliveira Nunes}}}
%\tituloestrangeiro{Canonical article template in \abnTeX: optional foreign title}
% ------------------------------------------------------------------------
% META DADOS DO PDF
% ------------------------------------------------------------------------
% Alterando o aspecto da cor azul
\definecolor{blue}{RGB}{41,5,195}
% Informações do PDF
\makeatletter
\hypersetup{
 	%pagebackref=true,
	pdftitle={\@title}, 
	pdfauthor={\@author},
	pdfsubject={\imprimirpreambulo},
    pdfcreator={LaTeX with abnTeX2 and Overleaf},
	pdfkeywords={abnt}{latex}{abntex}{abntex2}{atigo científico}, 
	colorlinks=false,       % false: boxed links; true: colored links
	linkcolor=blue,         % color of internal links
	citecolor=blue,        	% color of links to bibliography
	filecolor=magenta,      % color of file links
	urlcolor=blue,
	bookmarksdepth=4
}
\makeatother
% ------------------------------------------------------------------------
% CONFIGURAÇÕES DAS FOLHAS E AJUSTES NAS FONTES GERAIS
% ------------------------------------------------------------------------
% Compila o índice
\makeindex
% Altera as margens
\setlrmarginsandblock{3cm}{2cm}{*}
\setulmarginsandblock{3cm}{2cm}{*}
\checkandfixthelayout
% Espaçamentos entre linhas e parágrafos 
% O tamanho do parágrafo é dado por (espaçamento na primeira linha):
\setlength{\parindent}{1.25cm}
% O espeçamento padrão é definido como \OnehalfSpacing, ou seja, um espaço e meio conforme estabelece a ABNT NBR 14724:2011
% ------------------------------------------------------------------------
% CABEÇALHOS E RODAPÉS
% ------------------------------------------------------------------------
% Criar um novo estilo de cabeçalhos e rodapés
\pagestyle{fancy}
%\setlength{\headheight}{80pt}
\fancyhf{}
%\lhead{\includegraphics[width=0.4\textwidth]{/images/image00.png}}
%\rhead{
%{\fontsize{8}{1.5}\selectfont
%\begin{vplace}
%TCC - TRABALHO DE CONCLUSÃO DE CURSO\break
%COORDENAÇÂO DE ENGENHARIA DA COMPUTAÇÃO\end{vplace}}}
\fancypagestyle{plain}{
    \renewcommand{\headrulewidth}{0pt}
    \renewcommand{\footrulewidth}{0pt}
    \fancyhfoffset[LE]{0mm}
    \fancyhfoffset[RE]{0mm}
    \fancyhfoffset[LO]{0mm}
    \fancyhfoffset[RO]{0mm}
}
% ------------------------------------------------------------------------
% CAPÍTULOS, SEÇÕES E SUBSEÇÕES
% ------------------------------------------------------------------------
% Chapter 12pt + Bold
\renewcommand{\ABNTEXchapterfont}{\bfseries}
\renewcommand{\ABNTEXchapterfontsize}{\normalsize}
% Section 12pt + Bold
\renewcommand{\ABNTEXsectionfont}{\bfseries}
\renewcommand{\ABNTEXsectionfontsize}{\normalsize}
% SubSection 12pt
\renewcommand{\ABNTEXsubsectionfont}{\normalfont}
\renewcommand{\ABNTEXsubsectionfontsize}{\normalsize}
% SubSubSection 12pt + Bold + Underline
\renewcommand{\ABNTEXsubsubsectionfont}{\bfseries}
\renewcommand{\ABNTEXsubsubsectionfontsize}{\normalsize}
\setsubsubsecheadstyle{\ABNTEXsubsubsectionfont\ABNTEXsubsubsectionfontsize\ABNTEXsubsubsectionupperifneeded\coloruline[black]}
% SubSubSubSection 12pt + Lowercase
\setparaheadstyle{\normalfont\ABNTEXsubsubsectionfont\ABNTEXsubsubsectionfontsize}
% Retirando espaçamentos antes dos capítulos
\setlength{\beforechapskip}{\baselineskip}
% Retirando espaçamentos depois dos capítulos
\setlength{\afterchapskip}{\baselineskip}
% Recriando a variável que instancia o resumo
\renewenvironment{resumoumacoluna}{}

% ------------------------------------------------------------------------
% INÍCIO DO DOCUMENTO
% ------------------------------------------------------------------------
\begin{document}
% Seleciona o idioma do documento (conforme pacotes do babel)
%\selectlanguage{english}
\selectlanguage{brazil}
% Retira espaço extra obsoleto entre as frases.
\frenchspacing 
% ------------------------------------------------------------------------
% ELEMENTOS PRÉ-TEXTUAIS
% ------------------------------------------------------------------------
\pretextual
\pagestyle{fancy}
% página de titulo principal (obrigatório)
%\maketitle
\begin{SingleSpace}
    \begin{center}
        \imprimirtitulo
    \end{center}
    \begin{flushright}
        \imprimirautor
        \footnote{Graduando em Engenharia da Computação, UNIFACS. E-mail: felipe.rios.silva@outloook.com}
        \\
        \imprimirorientador
        \footnote{Docente Orientador Doutor em Processamento Digital de Imagens, UNIFACS. E-mail: eldman.nunes@unifacs.br}
    \end{flushright}
\end{SingleSpace}
% Titulo em outro idioma (opcional)
% Resumo em Português
\begin{resumoumacoluna}
    \footnotesize{\begin{SingleSpace}
        \noindent
        \textbf\resumoname\\
        Conforme a ABNT NBR 6022:2018, o resumo no idioma do documento é elemento obrigatório. Constituído de uma sequência de frases concisas e objetivas e não de uma simples enumeração de tópicos, não ultrapassando 250 palavras, seguido, logo abaixo, das palavras representativas do conteúdo do trabalho, isto é, palavras-chave e/ou descritores, conforme a NBR 6028. (\ldots) As palavras-chave devem figurar logo abaixo do resumo, antecedidas da expressão Palavras-chave:, separadas entre si por ponto e finalizadas também por ponto.\\\\
        \textbf{Palavras-chave:} latex. abntex. editoração de texto.
        \vspace{\onelineskip}
    \end{SingleSpace}}
\end{resumoumacoluna}
% Resumo em Inglês
\renewcommand{\resumoname}{Abstract}
\begin{resumoumacoluna}
    \footnotesize{\begin{SingleSpace}
        \begin{otherlanguage*}{english}
            \noindent
            \textbf\resumoname\\
            Conforme a ABNT NBR 6022:2018, o resumo no idioma do documento é elemento obrigatório. Constituído de uma sequência de frases concisas e objetivas e não de uma simples enumeração de tópicos, não ultrapassando 250 palavras, seguido, logo abaixo, das palavras representativas do conteúdo do trabalho, isto é, palavras-chave e/ou descritores, conforme a NBR 6028. (\ldots) As palavras-chave devem figurar logo abaixo do resumo, antecedidas da expressão Palavras-chave:, separadas entre si por ponto e finalizadas também por ponto.\\\\
            \textbf{Keywords:} latex. abntex.
        \end{otherlanguage*}
    \end{SingleSpace}}
\end{resumoumacoluna}
% ------------------------------------------------------------------------
% ELEMENTOS TEXTUAIS
% ------------------------------------------------------------------------
\textual
\pagestyle{fancy}
% ------------------------------------------------------------------------
% INTRODUÇÃO
% ------------------------------------------------------------------------
\section{Introdução}
% ---------------------------------
% TEMA
% ---------------------------------
A execução especulativa é uma técnica de projeto de microarquitetura, que proporciona o aprimoramento da velocidade de processamento nas CPU's modernas. Esta técnica consiste na estimativa e execução de instruções com valores ainda não conhecidos pela CPU, durante o curto período de carregamento dos valores reais. Do ponto de vista funcional, esta especulação traria problemas se os resultados de especulações incorretas fossem efetivados. Porém, quando a verdadeira informação é recuperada, a CPU verifica a exatidão da suposição e descarta o ``caminho'' (fluxo de execução) que foi executado incorretamente, eliminando os valores nos registradores ou alterações em variáveis, por exemplo \cite{Intel2016Architectures}.

Utilizando ataques que combinam a indução da execução especulativa e canais laterais, Jann Horn (\citeyear{Jann2018Reading}) e outros pesquisadores provaram que é possível recuperar informações privilegiadas (que foram especuladas), através da memória cache (um canal lateral), que não é revertida quando uma especulação errônea acontece \cite{Kocher2018Spectre}. A partir disto, com o conhecimento microarquitetural necessário, é possível um atacante induzir a execução especulativa errônea, por ``viciar'' o processador em uma cadeia de especulações e transferir as informações especuladas para um canal alternativo que pode ser lido posteriormente.

% ---------------------------------
% JUSTIFICATIVA
% ---------------------------------
Estes ataques que utilizam a combinação das duas técnicas, acontecem em condições específicas, ou seja, possuem axiomas\footnote{Axiomas são regras lógicas consideradas dignas de aceitação comum, segundo \citeonline{Encyclopaedia2011Axiom}.} bem definidos que podem ser questionados e provados. Mesmo assim, a abrangência destes ataques é considerável: é possível afirmar que praticamente todos os chips de arquitetura \emph{Intel}, \emph{AMD} e \emph{ARM}\footnote{\emph{Advanced RISC Machine}, ou ``Máquina Avançada de \emph{Instruções Reduzidas}'' (tradução e grifo do autor).}, foram afetados. Servidores na nuvem, celulares, \emph{desktops}, \emph{notebooks} e basicamente todos os chips que podem manter muitas instruções em execução, podem ter dados sigilosos comprometidos \cite{Graz2018Meltdown}. Segundo um guia de revisão\footnote{\emph{Microcode Revision Guidance}, publicado em abril de \citeyear{Intel2018Microcode}.} da \emph{Intel}, 193 processadores irão continuar com a falha, pois apresentaram instabilidade com as mitigações da vulnerabilidade.

Esta abrangência de processadores atingidos, torna esta vulnerabilidade um assunto relevante devido a probabilidade de que muitas máquinas, aparelhos móveis, \emph{datacenters} e consequentemente informações sigilosas estejam expostas. Isto acontece porque, tal categoria de vulnerabilidade se encontra em nível de \emph{hardware}, e correções via \emph{software} são paliativos que custam questões de desempenho e estabilidade.

% ---------------------------------
% PROBLEMA E QUESTÃO DE PESQUISA
% ---------------------------------
Considerando que os pesquisadores citados utilizaram \emph{softwares} com estruturas conhecidas (endereços de memória, tamanho e conteúdo das variáveis por exemplo) em seus experimentos, algumas questões ainda permanecem em aberto. Diante disto, é possível explorar informações sensíveis de \emph{softwares} cuja estrutura de memória seja desconhecida, por meio da exploração da execução especulativa induzida, utilizando canais laterais?

% ---------------------------------
% OBJETIVOS
% ---------------------------------
Através deste questionamento, esta pesquisa visa esclarecer, explicar e aplicar técnicas desenvolvidas pelos pesquisadores supramencionados. Visando elencar e comprovar os axiomas envolvidos e que realmente são necessários para se executar vazamentos de informações sensíveis. Tendo como foco, a exploração da execução especulativa em \emph{softwares} cujas estruturas se desconhece. De forma a solidificar limitações desta técnica de exploração em particular.

% ---------------------------------
% PROCEDIMENTOS METODOLÓGICOS
% ---------------------------------
E para a obtenção de êxito nesta busca por limitações da exploração destes dados sensíveis, esta pesquisa teve seus procedimentos e resultados técnicos analisados e avaliados em uma máquina real, induzida ao ambiente ideal para a realização dos experimentos. Portanto, cada experimento foi testado de forma exaustiva neste mesmo ambiente induzido. O intuito disto é promover o aprofundamento de um conhecimento já exposto através de pesquisas anteriores, sem descartar a possibilidade de produção de um conhecimento novo, que pode ser aplicado em estudos futuros sobre o assunto. Sendo assim, o autor espera complementar alguns aspectos e peculiaridades de pesquisas anteriormente feitas, preenchendo lacunas de conhecimento a respeito da exploração da execução especulativa.

% ---------------------------------
% ORGANIZAÇÃO DO ARTIGO
% ---------------------------------
Para melhor segmentação e explanação do conhecimento, as outras seções do artigo estão dispostas como se segue: a seção 2, \textbf{referencial teórico}, aborda os conceitos de \emph{pipeline}, \emph{branch condition}, \emph{branch target buffer}, \emph{cache levels}, canais laterais e execução especulativa. A seção 3, \textbf{referencial metodológico}, classifica a pesquisa e detalha os procedimentos metodológicos empregados. A seção 4, \textbf{resultados e discussões}, apresenta os experimentos e análises feitas a partir de códigos de outros pesquisadores e artigos relacionados, visando elicitar e testar os axiomas da técnica descrita. E a seção 5, apresenta a \textbf{conclusão}, discute os resultados alcançados, considerando limitações, perspectivas futuras e conclusões finais.

% ------------------------------------------------------------------------
% REFERENCIAL TEÓRICO
% ------------------------------------------------------------------------
\section{Referencial Teórico}
Com o objetivo de esclarecer e contextualizar o tema desta pesquisa, esta sessão aborda definições dos conceitos a respeito da execução especulativa, e complementos essenciais para o entendimento dos ataques que utilizam canais laterais. Além de abordar a trajetória histórica das descobertas de outros pesquisadores.

% ---------------------------------
% CONTEXTUALIZAÇÃO
% ---------------------------------
\subsection{Contextualização}
Dois grupos compostos respectivamente por: Jann Horn (\emph{Google Project Zero}); Paul Kocher em colaboração com Daniel Genkin (\emph{University of Pennsylvania} e \emph{University of Maryland}), Mike Hamburg (\emph{Rambus}), Moritz Lipp (\emph{Graz University of Technology}) e Yuval Yarom (\emph{University of Adelaide} e \emph{Data61}), em descobertas independentes (precedidos por Horn), relataram uma vulnerabilidade que afeta de forma abrangente arquiteturas \emph{Intel}, \emph{AMD} e \emph{ARM}.

Esta vulnerabilidade (comunicada aos fornecedores em 01 de Junho de 2017) que foi divulgada por Horn ao público (03 de Janeiro de \citeyear{Jann2018Reading}) com o nome de \emph{Spectre}\footnote{``Espectro'' (tradução do autor). Conforme \citeonline{Graz2018Meltdown}, o nome deriva da causa da falha.}, foi registada na CVE\footnote{\emph{Common Vulnerabilities and Exposures}, ``Exposições e Vulnerabilidades Comuns'' (tradução do autor). Mantida sem fins lucrativos pela Mitre \emph{Corporation}.}, na forma de duas variações: \emph{bypass} de verificação de limites (\emph{CVE-2017-5753}) e injeção do caminho alvo (\emph{CVE-2017-5715}). Estas duas variações foram documentadas cientificamente por \citeonline{Kocher2018Spectre}. Apenas a primeira variação será estudada nesta pesquisa. Isto porque, os ataques que a utilizam apresentam uma abrangência maior de alvos, do que até mesmo as outras variações e vulnerabilidades que sucederam esta descoberta de Horn.

Nesta mesma publicação de Horn (\citeyear{Jann2018Reading}) uma terceira variação de vulnerabilidade, que é também explorada utilizando canais laterais, foi divulgada e batizada de \emph{Meltdown}\footnote{Colapso, ou derreter (``melt'', inglês). O nome deriva da consequência da exploração da falha.}. Por sua vez, foi descoberta em paralelo por outro grupo de pesquisadores que sucedeu Horn \cite{Graz2018Meltdown}. Possui apenas um registro na CVE (\emph{CVE-2017-5754}), e tem uma abrangência de alvos limitada: processadores de arquitetura \emph{Intel} desde 1995 (exceto \emph{Intel Itanium} e \emph{Intel Atom} antes de 2013), e alguns de arquitetura \emph{ARM} \cite{Graz2018Meltdown}. Foi documentada cientificamente por \citeonline{Lipp2018Meltdown}.

Enquanto estas duas comprovações de Horn não haviam sido divulgadas, Anders Fogh (analista de \emph{malware} da empresa alemã \emph{GData}), em 28 de julho de \citeyear{Anders2017Reading}, elucidou a possibilidade de exploração da técnica de execução especulativa para ler a regiões privilegiadas de memória. Porém, obteve um resultado negativo em sua pesquisa, mantendo aberto um precedente para outros pesquisadores que posteriormente confirmariam suas suspeitas \cite{Andy2018Triple}.

Após as divulgações públicas, a \emph{Intel} comunicou em nota oficial o seu comprometimento em mitigar as falhas, estudando e disponibilizando \emph{firmwares} para corrigi-las (ou atenuá-las). Se defendendo também de especulações em relação ao desempenho dos processadores, depois das correções via \emph{software}, afirmou que qualquer diferença no desempenho ``depende da carga de trabalho e, para o usuário médio do computador, não deve ser significativo e será atenuado com o tempo'' \cite{Intel2018NewsIssues}. Depois disso, publicou um informativo de segurança, informando a lista de processadores da marca atingidos pelas vulnerabilidades e suas ramificações \cite{Intel2018SA00088}.

Outros fabricantes e fornecedores de aplicações diretamente afetados pelas vulnerabilidades também se mobilizaram, publicando informativos de segurança, e lançando correções a nível de \emph{software}. Fabricantes de \emph{consoles} de jogos que utilizam processadores \emph{AMD} ou de arquitetura \emph{ARM}, como \emph{Sony} e \emph{Nintendo}, não se pronunciaram, conforme lista oficial publicada pela Universidade de Tecnologia de Graz \cite{Graz2018Meltdown}.

% ---------------------------------
% TRABALHOS RELACIONADOS
% ---------------------------------
\subsection{Trabalhos Relacionados}
As descobertas supramencionadas abriram precedentes para outros questionamentos em relação a segurança dos processadores atuais. Questionamentos sobre quantas vulnerabilidades críticas como estas, podem estar ``adormecidas'' por anos, preocupam os pesquisadores \cite{Andy2018Triple}. E motivados por estas preocupações, outras vulnerabilidades foram descobertas, partindo do mesmo princípio de ataques que se aproveitam da execução especulativa. Em ordem cronológica, foram documentados: \emph{Foreshadow} e \emph{Foreshadow-NG}, em \citeonline{VanBulck2018Foreshadow}. \emph{Spoiler}, em \citeonline{Islam2019Spoiler}. \emph{ZombieLoad} em \citeonline{Schwarz2019ZombieLoad}. \emph{RIDL} em \citeonline{VanSchaik2019RIDL} e \emph{Fallout} em \citeonline{Minkin2019Fallout}.

A \emph{Spectre}, que dada a cronologia de descoberta, pode ser chamada de ``pioneira'' da execução especulativa, é complexa de ser explorada e possui condições específicas para exploração (axiomas). Apesar disso, até o momento de finalização desta pesquisa (junho de 2019), não havia sido descoberta uma solução clara ou totalmente eficaz contra a vulnerabilidade. Um grande esforço estava sendo feito para o desenvolvimento de medidas de prevenção via \emph{software}, para dificultar a exploração \cite{Graz2018Meltdown}.

\begin{comment}
Adicionar os 2 trabalhos discorridos sobre a Spectre.
\end{comment}

% ---------------------------------
% FUNDAMENTAÇÃO TEÓRICA
% ---------------------------------
\subsection{Fundamentação Teórica}
As funções que se encontram ordenadas em um fluxo para execução de um \emph{software} qualquer, de forma geral, são convertidas pelos processadores para instruções. E, dentro do núcleo do processador, estas instruções por sua vez, são convertidas para micro-operações \cite{Alisson2017Introducao}. A execução destas instruções pelo processador, acontece fora de ordem em grande parte dos momentos. Este paradigma é chamado de \textbf{execução fora de ordem} (\emph{out-of-order execution}) \cite{Fog2017Microarchitecture}.

É um paradigma que aumenta a utilização dos componentes do processador. Permite que instruções que sucedem o fluxo atual de execução, sejam executadas em paralelo, ou até mesmo antes do fluxo de execução atual. E, assim que as micro-operações de uma instrução são finalizadas, bem como as instruções que a antecedem, estas instruções são retiradas, obedecendo a ordem de execução predefinida. Limpando assim o \emph{buffer} de reordenação e efetivando as alterações nos registradores (variáveis do processador) \cite{Kocher2018Spectre}.

Durante o fluxo de execução deste \emph{software} qualquer, utilizado como exemplo, podem existir instruções de desvio: condicionais ou incondicionais. Quando o processador se depara com uma instrução de desvio condicional (chamada de \textbf{\emph{branch condition}}), muitas vezes ele não conhece quais são as instruções futuras. Pois, esta instrução de ramificação tem uma direção que depende das instruções precedentes, cuja execução ainda não está concluída. 

Esta situação é claramente vista quando observa-se o endereço de memória que aponta para a próxima instrução (que continuará o fluxo). Este endereço pode ser especificado de forma: imediata, endereço de memória fixo; direta, variável que contém o endereço de memória; ou indireta, endereço de memória de uma variável que contém o próximo salto \cite{Debarshi2018Addressing}. Quando o endereço de memória é especificado através de uma variável (de forma direta), e o conteúdo desta variável se trata do resultado de uma operação, tem-se uma condição propícia para uma ``especulação''.

Nestas situações, o processador pode preservar o estado dos registradores e variáveis, fazer uma previsão do caminho que o programa seguirá e executar instruções especulativamente ao longo deste caminho. Se a previsão estiver correta, os resultados desta execução serão confirmados (isto é, salvos nos registradores e variáveis), gerando uma vantagem de desempenho em relação ao tempo ocioso durante a espera. Caso contrário, o processador abandona o trabalho executado, revertendo o estado dos registradores e variáveis, continuando ao longo do caminho correto. Esta técnica é chamada de \textbf{execução especulativa} (\emph{speculative execution}) \cite{Kocher2018Spectre}.

Durante a execução especulativa, o processador faz suposições sobre o resultado provável das instruções de desvio. Previsões melhores consequentemente melhoram o desempenho, aumentando o número de operações executadas especulativamente que podem ser confirmadas com sucesso \cite{Kocher2018Spectre}. Esta técnica de previsão de resultados, aplicada a uma \emph{branch condition} é chamada de \textbf{\emph{branch prediction}}.

\citeonline{Kocher2018Spectre} chamou as instruções que são realizadas erroneamente em uma tentativa de execução especulativa (como resultado de uma previsão incorreta) de ``instruções transitórias'' (\textbf{\emph{transient instructions}}). Admitindo que tais instruções, embora não alterem o fluxo de execução de um \emph{software}, deixam rastros micro arquiteturais. Esses rastros em componentes micro arquiteturais podem ser chamados de \textbf{canais}.

O comportamento de prever uma ação futura, baseado em ações passadas, assumindo que a ação futura é semelhante a anterior, permite que alterações no estado de micro arquitetura causadas pelo comportamento de um \emph{software} possam afetar outros \emph{softwares}. E, ao longo do tempo, a exploração destas pequenas alterações foram comprovadas de diferentes formas, elicitadas por \citeonline{Kocher2018Spectre}. As explorações de componentes micro arquiteturais (canais), são chamadas de \textbf{ataques de canais laterais} (\emph{side-channals attacks}).

\begin{comment}
Isto porque, vários componentes do processador são usados para fazer o \emph{branch prediction}. Dois deles são o BTB e o RSB (\emph{Branch Target Buffer} e \emph{Return Stack Buffer}).

O BTB armazena um mapeamento de endereço de origem para endereço de destino, de instruções de desvio condicional (ramificações) recentes. E pode ser usado para prever destinos futuros, antes de terminar a decodificação da própria instrução de desvio \cite{Kocher2018Spectre}. Já o RSB é utilizado para armazenar em forma de pilha, os endereços de retorno das chamadas mais recentes. E pode ser usado como forma de prever, os próximos destinos de retornos, quando um retorno procurado é achado \cite{Esmaeil2018Spectre}. Ambos os componentes, são conhecidos somente pelos seus respectivos núcleos físicos do processador. Mesmo assim
\end{comment}



E, um destes rastros que é conhecido e costumeiramente explorado por ataques de canais laterais, está na memória cache.

A memória cache é abordada como algo singular, mas se refere a um conjunto de memórias, hierarquicamente subdivididas e organizadas. Um processador comum, inclui uma \textbf{hierarquia de memórias caches} em sua arquitetura. A cache que fica no topo, é chamada de L1 (\emph{level} 1 ou nível 1), é a menor e mais rápida. As L2 e L3, respeitam a ordem de serem maiores entre si conforme se avança de nível e perdem também em velocidade do mesmo modo.

Segundo \citeonline{Yarom2015MappingTI} nos processadores Intel modernos, o tamanho da cache L1 é de 64 KiB, com uma velocidade de acesso de 4 ciclos de CPU. Na L2, são 256 KiB com 7 ciclos. E, em cada núcleo do processador, tem-se níveis L1 e L2 dedicados. O terceiro nível (L3) é também chamado de LLC (\emph{last-level} cache). O tamanho da LLC varia entre os processadores (de 3 MiB a mais de 20 MiB), como também sua velocidade (26 a 31 ciclos de CPU). E é compartilhada entre os núcleos de um processador que é multinúcleos (\emph{multicores}).



\begin{comment}
Pipeline: é uma fila de instruções, que é organizada pela ordem de execução que cada instrução deve ser ou foi executada (processada por ciclo). É uma técnica de hardware também conhecida como “segmentação de instruções”, e é efetivada na memória do processador. É análogo a uma esteira de produção, onde cada “peça” entra em um setor específico que “processa” esta peça. E cada “setor”, só pode ser ocupado com uma peça por vez. Nisto, “peça” seria uma instrução computacional vinda da memória (D ou S) RAM e “setor”, uma fase que esta instrução precisa passar para atingir o seu objetivo na cadeia de processamento.

Exploração da Execução Especulativa: no artigo de Jann Horn et al. são demonstradas duas técnicas para exploração da execução especulativa:

Exploração das ramificações condicionais (conditional branches ou branch condition): consiste em “treinar” o processador a predizer o resultado de ramificações de forma que, este acerte determinado número de vezes. Depois, tenta acessar as ramificações com valores não permitidos, fazendo com que os resultados de especulações incorretas sejam revertidos (de forma esperada), porém armazenados na cache LLC. Depois, basta utilizar alguma técnica de extração dos dados contidos na cache.

Exploração do posicionamento de ramificações indiretas: consiste em “treinar” o BTB (Branch Target Buffer), que guarda os endereços que levarão instruções de saltos (ramificações) para o próximo fluxo de execução. O processo é similar a primeira técnica, porém o atacante substitui aqui os endereços de memória para onde o software originalmente deveria saltar, por outros endereços conhecidos pelo atacante.

Outras técnicas: Jann Horn deixou claro que variações destas explorações podem ser feitas como novas formas de ataque, mas não elucidou de que forma, e como isto poderia acontecer.
\end{comment}

% ---------------------------------
% CONCLUSÃO PARCIAL
% ---------------------------------
\subsection{Conclusão Parcial}

% ------------------------------------------------------------------------
% REFERENCIAL METODOLÓGICO
% ------------------------------------------------------------------------
\section{Referencial Metodológico}
Esta seção aborda a classificação da pesquisa com relação a finalidade, abordagem e procedimentos técnicos. Além de caracterizar e segmentar os procedimentos técnicos em passos.
% ---------------------------------
% CLASSIFICAÇÃO DA PESQUISA
% ---------------------------------
\subsection{Método}
Esta é uma pesquisa com finalidade de natureza básica, com objetivos de caráter explicativos, que utiliza uma abordagem quantitativa, com procedimentos fundamentados em pesquisa bibliográfica, documental e experimental. Caracterizada por um estudo transversal, levando em conta os resultados de análises e testes conduzidos em um ambiente previamente configurado, ou seja, em um laboratório.

Trata-se de uma \textbf{pesquisa básica} \cite{Fernando1987Por}, porque além de promover o aprofundamento de um conhecimento já exposto através de pesquisas anteriores, não se descarta a possibilidade de produção de novos conhecimentos sobre o assunto. Sendo assim, o autor espera complementar alguns aspectos e peculiaridades de pesquisas anteriormente feitas, preenchendo lacunas de conhecimento a respeito exploração da execução especulativa.

É uma \textbf{pesquisa explicativa} \cite{Rampazzo2005Metodologia}, pois tem por objetivo demonstrar a possibilidade de execução da técnica de vazamento, em circunstâncias específicas e diferentes das circunstâncias abordadas no artigo de \citeonline{Kocher2018Spectre}. Essa comparação leva em conta artigos de outros pesquisadores, que elucidaram limites que estão envolvidos na aplicação da técnica. Existindo assim, uma associação entre os limites elicitados, a comprovação ou não destes, e a busca de outros limites, para a consolidação dos axiomas.

A pesquisa utiliza uma \textbf{abordagem quantitativa} \cite{Mauro2009Metodologia}, visto que a avaliação dos resultados possui caráter bem definido e exato do ponto de vista funcional. Avalia-se a execução ou não dos procedimentos que levam ao vazamento, e concluir-se de forma objetiva e direta se a técnica funciona ou não, com que circunstâncias e com quais condições (axiomas da técnica). Tais resultados foram comprovados através de experimentos, embasados na literatura referencial.

Os procedimentos técnicos adotados pelo autor baseiam-se em técnicas de pequisa bibliográfica, documental e experimental. O \textbf{procedimento bibliográfico} foi adotado pois proporciona a condição de comparação histórica com a literatura, além de conferir o embasamento teórico veraz necessário (desconsiderando literaturas sensacionalistas, imprecisas ou sem fontes sólidas), creditando aos autores primários suas devidas contribuições para o ponto atingido deste trabalho. O \textbf{procedimento documental} confere a garantia de consulta e comparação dos artigos primários, com a literatura não processada (manuais, guias e notas oficiais dos fabricantes). E o \textbf{procedimento experimental} proporcionou ao autor agregar valor ao trabalho em questão através de experimentos com retestes. Utilizando como objetos de estudo os \emph{softwares} desenvolvidos por outros pesquisadores, afim de obter resultados diferentes com modificações pontuais, visando o acréscimo de um conhecimento anterior \cite{Praca2015Metodologia}.

Estes procedimentos técnicos, juntamente com os resultados, foram analisados e avaliados durante um determinado período de tempo. Sendo que, as variáveis observadas são relativas a momentos instantâneos de regiões dinâmicas de memória, conferindo uma característica \textbf{transversal} ao estudo, tratando-se de tempo de aplicação \cite{Mauro2009Metodologia}.

A localização da realização desta pesquisa, refere-se a um \textbf{ambiente controlado} composto de um computador pessoal. Este ambiente laboratorial foi previamente configurado, para simular a ausência de defesa contra a técnica de vazamento em questão. Foi necessário testar a mesma técnica no mesmo cenário criado, de forma exaustiva, evidenciando cada limite encontrado para a consolidação dos axiomas da técnica.

% ---------------------------------
% DESCRIÇÃO DOS PROCEDIMENTOS
% ---------------------------------
\subsection{Procedimentos}
Para a realização dos experimentos, utilizou-se a prova de conceito (\emph{Proof of Concept}, ou \emph{PoC}) documentada por \citeonline{Kocher2018Spectre}. O código exemplo de exploração (ou \emph{exploit}\footnote{Segundo  \citeonline{Cesar2010Vulnerabilidades}, é um conjunto de instruções ``capaz de tirar proveito de uma vulnerabilidade''.}) desta \emph{PoC}, foi escrito em linguagem C, e simula o vazamento de uma informação secreta escrita diretamente no código. O intuito é explorar a execução especulativa induzida, utilizando a memória cache como canal lateral, em uma estrutura (endereços de memória e variáveis) definida pelo próprio criador do \emph{exploit}. 

De posse deste \emph{exploit} e utilizando uma máquina convencional que contenha um compilador de C (\textbf{Visual C++} para \emph{Windows}, ou \textbf{GNU Compiler Collection} para \emph{Linux}), é possível verificar os passos que desencadeiam o vazamento. No caso desta pesquisa, o ambiente utilizado foi um Linux GNU Ubuntu 16.04.05 LTS 64-bit, Intel\textsuperscript{\tiny\textregistered} Core\textsuperscript{\tiny\texttrademark} i3 5005U @ 2.0 Ghz x 4. Diante disto, os experimentos para a realização desta pesquisa foram divididos em quatro testes (T01 à T04), que apresentam-se como possíveis axiomas da \emph{Spectre}. Tendo como foco, a utilização do \emph{exploit} em uma estrutura contrária ao documentado por \citeonline{Kocher2018Spectre}: endereços de memória desconhecidos, tamanho e conteúdo das variáveis escolhidos de forma adversa.

Dois métodos foram utilizados para elicitar estes \textbf{possíveis axiomas}: exploração da literatura, em busca de circunstancias que sejam necessárias para a execução da \emph{Spectre}; e, exploração do \emph{exploit}, em busca de limitações intuitivas que determinam o funcionamento da \emph{PoC}. Posteriormente estes foram testados, afim de identificar com as suas possíveis falhas, em quais circunstâncias gerais e de comum aceitação a \emph{Spectre} funciona ou limita-se: quanto a endereços de memória (físicos ou não) que abrangem o vazamento, quanto a quantidade de dados que pode ser vazada, e quanto a aplicação genérica da vulnerabilidade para leitura arbitrária de memória privilegiada, sem autorização.

\begin{comment}
Para a realização dos passos supradescritos, os ambientes utilizados foram: GNU Ubuntu 18.04.01 LTS 64-bit, Intel\textsuperscript{\tiny\textregistered} Core\textsuperscript{\tiny\texttrademark} i7 7500U @ 2.7 Ghz x 4; GNU Ubuntu 16.04.05 LTS 64-bit, Intel\textsuperscript{\tiny\textregistered} Core\textsuperscript{\tiny\texttrademark} i3 5005U @ 2.0 Ghz x 4.
\end{comment}

% ------------------------------------------------------------------------
% TESTES E RESULTADOS
% ------------------------------------------------------------------------
\section{Testes e Resultados}
Esta seção tem por objetivo expor os testes realizados de maneira sistemática, com seus resultados individuais, abrindo questionamentos a respeito do conhecimento estudado. Ao final desta seção, uma discussão apresenta uma síntese do produto gerado pelos experimentos.
% ---------------------------------
% T01
% ---------------------------------
\subsection{T01 - Fora de contexto com endereço físico}
Conforme \citeonline{Kocher2018Spectre}, os ataques utilizando \emph{Spectre} são efetivos para as informações que a vítima tem acesso. Este tipo de ataque não escala privilégios e não é detido pelo mecanismo \emph{KAISER}. Mesmo assim, a literatura referencial afirma que é possível realizar vazamentos de dados que estão fora do contexto do atacante. Limitando-se apenas aos dados que o contexto da vítima tem acesso. O objetivo deste experimento é comprovar que o \emph{exploit} da \emph{Spectre} pode realizar estes vazamentos.

A partir disto, utilizando uma função que recebe o \emph{PID} (\emph{Process ID}) e o endereço virtual de uma variável (neste caso a secreta), foi possível obter o endereço físico (endereço real) de uma variável qualquer, criada em um contexto de aplicação pelo autor (processo diferente do \emph{exploit}). Com este endereço físico em mãos, e aplicado ao \emph{exploit} no lugar do cálculo de endereçamento inicial, as inferências foram iniciadas com um intervalo de 1 MB somado ao endereço físico inicial (margem de erro, para localizar o conteúdo da variável).

Após o termino das inferências (5 minutos), foi possível perceber que não é possível inferir dados de outro contexto, utilizando o endereço físico. Porque primeiro, o sistema operacional limita o acesso, mesmo que seja de somente leitura a outras variáveis de outros contextos. E segundo, é preciso utilizar privilégios superiores aos de usuário normal para adquirir o endereço físico de uma variável qualquer de outro processo.

\begin{comment}
https://www.eqware.net/articles/CapturingProcessMemoryUsageUnderLinux/index.html
https://stackoverflow.com/questions/5748492/is-there-any-api-for-determining-the-physical-address-from-virtual-address-in-li/45128487#45128487
\end{comment}

% ---------------------------------
% T02
% ---------------------------------
\subsection{T02 - Fora de contexto com \emph{flush} da cache}
Usando ainda a afirmação de \citeonline{Kocher2018Spectre}, a respeito da execução da \emph{Spectre} em contextos distintos, foi possível elencar outra estratégia de execução do \emph{exploit} em outros contextos. O objetivo deste experimento é testar outra possibilidade de vazamento utilizando contextos diferentes, porém, aplicando a técnica de \emph{Flush+Reload} do cache.

O \emph{exploit} foi adaptado em diversos pontos, de forma a permitir que a vítima e o atacante executassem de forma simultânea em binários diferentes. A vítima foi preparada para receber por argumento de inicialização, variáveis que podem estourar sua estrutura condicional vulnerável. O contexto atacante foi acrescido de funções para mapear os endereços físicos de duas variáveis do espaço da vítima, afim de capturar a diferença entre o vetor de exploração e o vetor secreto de caracteres. Com esta diferença em mãos, era esperado estourar o vetor de exploração e atingir caracteres secretos sem provocar sinais de \emph{SIGSEGV} na execução.

No locais onde a instrução \lstinline[language=C, style=c]{_mm_clflush} era utilizada, foi inserida uma função para realizar \emph{Flush+Reload} da memória cache, com instruções em \emph{Assembly}. Espera-se efetuar o \emph{flush} de endereços físicos de outro contexto, para a concretização da técnica, pois as chamadas exaustivas que provocarão o \emph{reload} estão funcionando de maneira teórica.

Após os testes, a aplicação atacante parou sua execução com um sinal de \emph{SIGSERV (Segmentation fault)}. Acusando a não permissão de realização do \emph{flush} de um endereço físico, fora do próprio contexto. Isto acontece pois, segundo \emph{Intrinsics Guide} da \emph{Intel}, instruções de \emph{flush} são utilizadas para limpar uma informação de mesmo contexto, em todos os níveis da hierarquia da cache \cite{Intel2018Intrinsics}. E, ao especular os dados o \emph{exploit} precisa fazer o ciclo de tentativa de acesso e limpeza da cache sucessivas vezes, inferindo o menor tempo de acesso das variáveis. Quando isto não ocorre no mesmo contexto, o \emph{exploit} não é capaz de manipular o comportamento da memória cache, e portanto, não consegue realizar as inferências.

\begin{comment}
explicar mais sobre o que é "contexto" nesse sentindo
pesquisar instruções não-temporais
\end{comment}

% ---------------------------------
% T03
% ---------------------------------
\subsection{T03 - Limite de tamanho da cache}
As especificações da \emph{Intel} (\citeyear{Intel2019Corei3}) e \emph{CPU Wolrd} (\citeyear{CPU2016Corei3}), documentam o tamanho da hierarquia da memória cache, utilizada neste experimento. É possível confirmar estes valores utilizando o comando\footnote{Documentado nas páginas do manual do \emph{Ubuntu} (\citeyear{Ubuntu2019Lscpu}).}: \lstinline[language=C, style=c]{lscpu | grep "cache"}. Que tem como resultado os valores de cada unidade na hierarquia: \textbf{L1d: 32K} (dados), \textbf{L1i: 32K} (instruções), \textbf{L2: 256K}, \textbf{L3: 3072K}. Objetiva-se comprovar que é possível utilizar o \emph{exploit} da \emph{Spectre}, fora dos limites que a memória cache do processador em questão é capaz de suportar. Aplicando tamanhos e conteúdos dinâmicos nas variáveis. Diferente do modelo original no código do \emph{exploit}, que contém variáveis com o conteúdo estático e tamanho fixo. Será levado em conta o tamanho da cache \emph{LLC}, pois o \emph{branch predictor} pode fazer um cache \emph{hit} em qualquer nível de cache.

\lstinputlisting[language=C, style=c, caption={Contagem do tempo de execução e geração do vetor randômico.}, label={lst:01}]{listings/list01.c}

Antes de iniciar as modificações pontais, o \emph{exploit} foi adaptado para ter seu tempo de execução calculado, contando a partir do inicio da fase de treinamento (conforme a figura \ref{lst:01}). Após isto, a primeira modificação feita para este experimento, foi o aumento do tamanho da informação secreta no código do \emph{exploit}. Aumentado de 40 bytes, para um valor randômico entre 3072 e 4072 Kbytes (conforme a figura \ref{lst:01}). Este vetor de caracteres foi preenchido randomicamente, e submetido ao código do \emph{exploit} para inferência das variáveis. Era esperado que a memória cache removesse os valores iniciais, e somente os valores finais pudessem ser inferidos.

Após a finalização deste experimento, conclui-se que, ao saber o ponteiro de inicio da variável que contém a informação secreta, e de posse do tamanho desta informação, é possível inferir todos os dados em uma velocidade de aproximadamente \textbf{5.46 KB/s} (3 MB em 562 segundos, para o ambiente em questão). Mesmo que a informação inferida seja maior que a memória cache. Isto porque, a transferência dos dados acontece com um endereço por vez. Cada endereço inferido passa por 3 fazes: treinamento (\emph{loop} que acontece 30 vezes), leitura (\emph{loop} de 256 vezes) e inferência da melhor leitura (\emph{loop} de 256 vezes). Sendo que, cada etapa ocorre 999 vezes, garantindo um \textbf{acurácia de 0,01\%} nos resultados, conforme \citeonline{Kocher2018Spectre}.

% ---------------------------------
% T04
% ---------------------------------
\subsection{T04 - Utilização de \emph{bit twiddling}}
A figura \ref{lst:02} contém um trecho do \emph{exploit} chamado de \emph{bit twiddling} pelos autores. Este trecho de código está presente no \emph{exploit}, para unicamente simular o funcionamento de uma estrutura condicional. Segundo \citeonline{Kocher2018Spectre}, as estruturas condicionais ativam o \emph{branch predictor}, e durante a faze de \emph{misstraining} da memória cache, o \emph{predictor} não deveria ser chamado, pois adicionaria mais linhas na cache, e de certa forma agregando imprecisão a inferência do \emph{exploit}.

\lstinputlisting[language=C, style=c, caption={\emph{Bit twiddling} no código do \emph{exploit}.}, label={lst:02}]{listings/list02.c}

Trocando esta estrutura de \emph{bit twiddling}, para uma estrutura condicional convencional, espera-se provar que o grau de imprecisão agregado ao \emph{exploit} não é relevante para a checagem das informações. Sendo esta troca bem sucedida, tem-se uma variação do \emph{exploit} mais legível e fácil de se interpretar.

Após a troca das estruturas condicionais, conclui-se que ao ativar o \emph{branch predictor} na fase de treinamento, faz com que o \emph{BTB} perca as referencias, e consequentemente afete a inferência de dados do \emph{exploit}. Também foi percebido que isso só acontece no contexto atual. Pois quando o \emph{exploit} foi testado, outras atividades estavam ocorrendo na máquina alvo, e isto não afetou as inferências de informações.

% ---------------------------------
% DISCUSSÃO
% ---------------------------------
\subsection{Discussão}
Com a finalização dos experimentos, foi possível comprovar que algumas condições específicas são imprescindíveis para fazer uma informação vazar através da exploração da execução especulativa. A variação 01 da \emph{Spectre} possuí axiomas bem definidos e específicos, que não estavam fundamentalmente claros na literatura. 

A \emph{PoC} da \emph{Spectre} acontece em contextos iguais de forma absoluta, e em contextos diferentes de forma relativa. Quando \citeonline{Kocher2018Spectre} cita que "um atacante pode ler memória arbitrária de um outro contexto", ele quer dizer que esse outro contexto é subcontexto de um pai. E tanto o atacante, quanto a vítima, pertencem ao mesmo subcontexto pai. Esse é um dos axiomas de execução da \emph{Spectre}.

Além de estarem no mesmo contexto pai, vítima e atacante devem compartilhar de determinada região de memória. Isto é um axioma também verdadeiro. Conforme os experimentos feitos, não existe possibilidade de manipulação da memória cache, nem de calculo de endereços de variáveis, cujo atacante não conhece ou não tem acesso. Seria necessário que a própria vítima mostrasse os endereços físicos, e mesmo assim, o sistema operacional nega as solicitações de \emph{flush} destes endereços físicos.

% Finaliza a parte no bookmark do PDF, para que se inicie o bookmark na raiz
\bookmarksetup{startatroot}
% ------------------------------------------------------------------------
% CONCLUSÃO
% ------------------------------------------------------------------------
\section{Conclusão}
%\lipsum[31]
% ------------------------------------------------------------------------
% ELEMENTOS PÓS-TEXTUAIS
% ------------------------------------------------------------------------
\postextual
% ------------------------------------------------------------------------
% REFERẼNCIAS
% ------------------------------------------------------------------------
\bibliography{references}
% ------------------------------------------------------------------------
% APÊNDICES
% ------------------------------------------------------------------------
\begin{apendicesenv}
%\chapter{Cras non urna sed feugiat cum sociis natoque penatibus et magnis dis parturient montes nascetur ridiculus mus}
%\lipsum[31]
\end{apendicesenv}
% ------------------------------------------------------------------------
% ANEXOS
% ------------------------------------------------------------------------
\begin{anexosenv}
\vspace{\onelineskip}
%\chapter{Cras non urna sed feugiat cum sociis natoque penatibus et magnis dis parturient montes nascetur ridiculus mus}
%\lipsum[31]
\end{anexosenv}
% ------------------------------------------------------------------------
% AGRADECIMENTOS
% ------------------------------------------------------------------------
\section*{Agradecimentos}
%\lipsum[31]
% ------------------------------------------------------------------------
% FINAL DO DOCUMENTO
% ------------------------------------------------------------------------
\end{document}